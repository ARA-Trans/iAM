using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using DatabaseManager;
using OfficeOpenXml;
using OfficeOpenXml.Style;

namespace Reports.MDSHA.AllSectionsShopDmYrVmt
{
    /// <summary>
    ///     Represents all information necessary to generate the "All Sections"
    ///     report.
    /// </summary>
    public class Report : ReportBase
    {
        /// <summary>
        ///     This is the generic title of this type of report.
        /// </summary>
        /// <remarks>
        ///     This is a const string so that it can be used in a switch
        ///     statement that discerns report types based on name. As of this
        ///     writing, it is not yet used that way (though previous reports
        ///     were, so here we are, just in case).
        /// </remarks>
        public const string GenericTitle = "All Sections Shop DM Year & VMT";

        #region QueryTemplate for simulation analysis years
        private static readonly string QueryTemplate =
            new FormattedSql(@"
   SELECT 
   VAL_RSL.SECTIONID
   ,VAL_RSL.YEAR_ ""YEAR""
   ,'http://shagbegis1/egis/?initContent=124' || CHR(38) || 'initAttQuery=GLOBAL_ROUTE_ID%3D' || 
   VAL_RSL.GLOBAL_ROUTE_ID ||
   '%20and%20ID_MP%3E%3D' || 
   VAL_RSL.BEGIN_STATION || 
   '%20and%20ID_MP%3C%3D' || 
   VAL_RSL.END_STATION ||
   '%20and%20MP_DIRECTION%3DCAL_DIRECTION' || CHR(38) || 'initQueryLayer=100th%20milepoints' || CHR(38) || 'initQueryZoom=true' AS EGIS
  ,CAST(VAL_RSL.DISTRICT AS INT) ""DISTRICT""
  ,VAL_RSL.FACILITY
  ,VAL_RSL.SECTION
  ,VAL_RSL.BEGIN_STATION ""BEGIN STATION""
  ,VAL_RSL.END_STATION ""END STATION""
  ,VAL_RSL.SHOP
  ,VAL_RSL.DIR_MILES ""DIR MILES""
  ,VAL_RSL.BEGIN_LIMIT ""BEGIN LIMIT""
  ,VAL_RSL.END_LIMIT ""END LIMIT""
  ,VAL_RSL.DIRECTION
  ,CAST(VAL_RSL.FUNC_CLASS AS INT) ""FUNC CLASS""
  ,VAL_RSL.DIVIDED
  ,VAL_RSL.AREA ""LANE MILES""
  ,VAL_RSL.AADT
  ,VAL_RSL.VMT
  ,CAST(VAL_RSL.GOVT_CONTROL AS INT) ""GOVT CONTROL""
  ,CASE WHEN VAL_RSL.NHS_CODE > 0 THEN 'Yes' ELSE 'No' END NHS
  ,VAL_RSL.PAVEMENT_TYPE ""PAVEMENT TYPE""
  ,CAST(VAL_RSL.GLOBAL_ROUTE_ID AS INT) ""GLOBAL ROUTE ID""
 -- ,VAL_RSL.LAST_TREATMENT ""LAST TREATMENT""
 -- ,CAST(VAL_RSL.LAST_YEAR AS INT) ""LAST YEAR""
  ,VAL_RSL.LAST_REHAB_TREATMENT AS ""LAST REHAB TREATMENT"" --  ,VAL_RSL.LAST_REHAB_TREATMENT
  ,CAST(VAL_RSL.LAST_REHAB_YEAR AS INT) AS ""LAST REHAB YEAR"" --  ,VAL_RSL.LAST_REHAB_YEAR
  ,VAL_RSL.LAST_MAINT_TREATMENT AS ""LAST MAINT TREATMENT"" --  ,VAL_RSL.LAST_MAINT_TREATMENT
  ,CAST(VAL_RSL.LAST_MAINT_YEAR AS INT) AS ""LAST MAINT YEAR"" --  ,VAL_RSL.LAST_MAINT_YEAR
  ,CASE WHEN VAL_RSL.PUBLIC_MAP_15 IS NOT NULL THEN 'Yes' ELSE NULL END ""GOVERNOR'S LIST PROJECT?""
  ,VAL_RSL.ROAD_CLASS ""ROAD CLASS""
--  ,CAST(VAL_RSL.FC_CATEGORY AS INT) ""FC CATEGORY""
--  ,VAL_RSL.TOTAL_LANES ""TOTAL LANES""
  ,VAL_RSL.AVG_IRI ""AVG IRI""
  ,VAL_RSL.CI_FUNCTIONAL ""FCI""
  ,VAL_RSL.CI_STRUCTURAL ""SCI""
  ,VAL_RSL.AVG_RUT ""AVG RUT""
  ,VAL_RSL.SPADJ_SKID_NUMBER ""SKID NUMBER""
  ,VAL_RSL.FAULTING  --placeholder for Faulting
  ,VAL_RSL.JC_CRACKED_SLABS AS ""JC CRACKED SLABS""  --placeholder for JC Cracked Slabs
  ,VAL_RSL.CRC_CRACKING_PERCENT AS ""CRC CRACKING PERCENT""  --placeholder for CRC Cracking Percent
  ,RSL_QRY.IRI_RSL ""IRI RSL""
  ,RSL_QRY.FCI_RSL ""FCI RSL""
  ,RSL_QRY.SCI_RSL ""SCI RSL""
  ,RSL_QRY.RUT_RSL ""RUT RSL""
  ,RSL_QRY.SKID_RSL ""SKID RSL""
  ,CASE 
    WHEN RSL_QRY.IRI_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.IRI_RSL
    WHEN RSL_QRY.FCI_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.FCI_RSL
    WHEN RSL_QRY.SCI_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.SCI_RSL
    WHEN RSL_QRY.RUT_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.RUT_RSL
    WHEN RSL_QRY.SKID_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.RUT_RSL THEN RSL_QRY.SKID_RSL 
  END ""RSL OVERALL""
FROM

(SELECT SEC.SECTIONID,
  REP.YEARS YEAR_,
  SEG.DISTRICT DISTRICT,
  SEC.FACILITY,
  CASE
    WHEN SEC.BEGIN_STATION > 0
    AND SEC.BEGIN_STATION  < 1
    THEN '0'|| SEC.BEGIN_STATION
    ELSE TRIM(TO_CHAR(SEC.BEGIN_STATION))
  END
  || '-'
  ||
  CASE
    WHEN SEC.END_STATION > 0
    AND SEC.END_STATION  < 1
    THEN '0'|| SEC.END_STATION
    ELSE TRIM(TO_CHAR(SEC.END_STATION))
  END
  || '('
  || SEC.DIRECTION
  || ')' SECTION,
  SEC.BEGIN_STATION,
  SEC.END_STATION,
  SEG.SHOP,
  (SEC.END_STATION - SEC.BEGIN_STATION) DIR_MILES,
  SEG.BEGIN_LIMIT,
  SEG.END_LIMIT,
  CASE
    WHEN SEG.DIVIDED = 'DIVIDED'
    THEN SEC.DIRECTION
      || 'B ONLY'
    ELSE 'ALL DIR'
  END DIRECTION,
  SEG.FUNC_CLASS,
  SEG.DIVIDED,
  SEC.AREA,    
  ROUND(SIM.AADT_VMT_{2} * (SEC.END_STATION - SEC.BEGIN_STATION), 0) VMT,
  SEG.GOVT_CONTROL,
  SEG.NHS_CODE,
  SIM.PAVEMENT_TYPE_{2} PAVEMENT_TYPE,
  SEG.GLOBAL_ROUTE_ID,
  SIM.LAST_TREATMENT_{2} LAST_TREATMENT,
  SEG.LAST_YEAR,
  SEG.LAST_REHAB_TREATMENT,
  SEG.LAST_REHAB_YEAR,
  SEG.LAST_MAINT_TREATMENT,
  SEG.LAST_MAINT_YEAR,
  SEG.PUBLIC_MAP_15,
  SEG.ROAD_CLASS,
--  SEG.FC_CATEGORY,
--  SEG.TOTAL_LANES,
  SIM.AADT_VMT_{2} AADT,
  SIM.AVG_IRI_{2} AVG_IRI,
  SIM.CI_FUNCTIONAL_{2} CI_FUNCTIONAL,
  SIM.CI_STRUCTURAL_{2} CI_STRUCTURAL,
  SIM.AVG_RUT_{2} AVG_RUT,
  CASE WHEN SEG.AGE IS NULL THEN SEG.SPADJ_SKID_NUMBER ELSE SIM.SPADJ_SKID_NUMBER_{2} END SPADJ_SKID_NUMBER,
  SIM.FAULTING_{2} FAULTING,
  SIM.JC_CRACKED_SLABS_{2} JC_CRACKED_SLABS,
  SIM.CRC_CRACKING_PERCENT_{2} CRC CRACKING PERCENT
  FROM SIMULATION_{0}_{1} SIM,
  SECTION_{0} SEC,
  SEGMENT_{0}_NS0 SEG,
  REPORT_{0}_{1} REP
  WHERE 
  SEG.SECTIONID = SIM.SECTIONID
  AND SIM.SECTIONID =REP.SECTIONID
  AND SEG.SECTIONID = SEC.SECTIONID
  AND REP.YEARS = {2}
  ORDER BY 1,2
) VAL_RSL,  -- subquery VAL_RSL returns select attribute-value pairs for each section and year

(SELECT *
FROM
  (SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(IRI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END IRI_RSL
    FROM
    (
    SELECT 
    CONDITIONAL_RSL.ATTRIBUTE,
    SL_IN.FUNC_CLASS,
    CONDITIONAL_RSL.BIN,
    CONDITIONAL_RSL.VALUE,
    SL_IN.SLOPE, 
    SL_IN.INTERCEPT
    FROM CONDITIONAL_RSL,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM CONDITIONAL_RSL   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
           
           UNION
           
          SELECT ATTRIBUTE, 
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
           CRITERIA,
          '50' END_BIN,  
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM CONDITIONAL_RSL   
           WHERE BIN IN (20,50)
           GROUP BY ATTRIBUTE,
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
          ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
          
          WHERE CONDITIONAL_RSL.ATTRIBUTE = SL_IN.ATTRIBUTE
          AND CONDITIONAL_RSL.CRITERIA = SL_IN.CRITERIA
          AND CONDITIONAL_RSL.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table CONDITIONAL_RSL to bring in fields from the CONDITIONAL_RSL table 
        
      (SELECT 
        SIM.SECTIONID,
        SEG.FUNC_CLASS,
        'AVG_IRI' ATTRIBUTE_,
      SIM.AVG_IRI_{2} VALUE_,
      REP.YEARS YEAR_
      FROM SIMULATION_{0}_{1} SIM,
        SECTION_{0} SEC,
        SEGMENT_{0}_NS0 SEG,        
        REPORT_{0}_{1} REP        

      WHERE 
      SEG.SECTIONID = SIM.SECTIONID
      AND SEC.SECTIONID = SIM.SECTIONID
      AND REP.SECTIONID = SIM.SECTIONID
      AND REP.YEARS = {2}         
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate IRI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
    
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(RUT_RSL) RSL
  FROM
    (
      SELECT Q1.SECTIONID, 
      Q1.ATTRIBUTE_,
      Q1.VALUE_,
      SLOPE_INTERCEPT.VALUE,
      Q1.YEAR_,
      SLOPE_INTERCEPT.FUNC_CLASS,
      SLOPE_INTERCEPT.BIN,
      CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in CONDITIONAL_RSL table 
        (CASE 
        WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
        WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
        WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
        THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
        END)
      ELSE --positive slope indicates that the attribute increases 0-50 in CONDITIONAL_RSL table 
        (CASE 
        WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
        WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
        WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
        THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
        END)
      END RUT_RSL 
      FROM
      (
        SELECT 
        CONDITIONAL_RSL.ATTRIBUTE,
        SL_IN.FUNC_CLASS,
        CONDITIONAL_RSL.BIN,
        CONDITIONAL_RSL.VALUE,
        SL_IN.SLOPE, 
        SL_IN.INTERCEPT
        FROM CONDITIONAL_RSL,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM CONDITIONAL_RSL   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
         
          UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM CONDITIONAL_RSL   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
      ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE CONDITIONAL_RSL.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND CONDITIONAL_RSL.CRITERIA = SL_IN.CRITERIA
        AND CONDITIONAL_RSL.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table CONDITIONAL_RSL to bring in fields from the CONDITIONAL_RSL table 
        
      (SELECT 
        SIM.SECTIONID,
        SEG.FUNC_CLASS,
        'AVG_RUT' ATTRIBUTE_,
      SIM.AVG_RUT_{2} VALUE_,
      REP.YEARS YEAR_
      FROM SIMULATION_{0}_{1} SIM,
        SECTION_{0} SEC,
        SEGMENT_{0}_NS0 SEG,        
        REPORT_{0}_{1} REP        

      WHERE 
      SEG.SECTIONID = SIM.SECTIONID
      AND SEC.SECTIONID = SIM.SECTIONID
      AND REP.SECTIONID = SIM.SECTIONID
      AND REP.YEARS = {2}         
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate RUT RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(SCI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END SCI_RSL
    FROM
    (
      SELECT 
      CONDITIONAL_RSL.ATTRIBUTE,
      SL_IN.FUNC_CLASS,
      CONDITIONAL_RSL.BIN,
      CONDITIONAL_RSL.VALUE,
      SL_IN.SLOPE, 
      SL_IN.INTERCEPT
      FROM CONDITIONAL_RSL,
      (
        SELECT ATTRIBUTE, 
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
        CRITERIA,
        '20' END_BIN,
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM CONDITIONAL_RSL   
         WHERE BIN IN (0,20)
         GROUP BY ATTRIBUTE,
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
         
        UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM CONDITIONAL_RSL   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
        ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE CONDITIONAL_RSL.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND CONDITIONAL_RSL.CRITERIA = SL_IN.CRITERIA
        AND CONDITIONAL_RSL.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table CONDITIONAL_RSL to bring in fields from the CONDITIONAL_RSL table 
        
      (SELECT 
        SIM.SECTIONID,
        SEG.FUNC_CLASS,
        'CI_STRUCTURAL' ATTRIBUTE_,
      SIM.CI_STRUCTURAL_{2} VALUE_,
      REP.YEARS YEAR_
      FROM SIMULATION_{0}_{1} SIM,
        SECTION_{0} SEC,
        SEGMENT_{0}_NS0 SEG,        
        REPORT_{0}_{1} REP        

      WHERE 
      SEG.SECTIONID = SIM.SECTIONID
      AND SEC.SECTIONID = SIM.SECTIONID
      AND REP.SECTIONID = SIM.SECTIONID
      AND REP.YEARS = {2}         
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate SCI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(FCI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END FCI_RSL
    FROM
    (
    SELECT 
    CONDITIONAL_RSL.ATTRIBUTE,
    SL_IN.FUNC_CLASS,
    CONDITIONAL_RSL.BIN,
    CONDITIONAL_RSL.VALUE,
    SL_IN.SLOPE, 
    SL_IN.INTERCEPT
    FROM CONDITIONAL_RSL,
      (
      SELECT ATTRIBUTE, 
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
        CRITERIA,
        '20' END_BIN,
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM CONDITIONAL_RSL   
         WHERE BIN IN (0,20)
         GROUP BY ATTRIBUTE,
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
         
        UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM CONDITIONAL_RSL   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
        ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE CONDITIONAL_RSL.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND CONDITIONAL_RSL.CRITERIA = SL_IN.CRITERIA
        AND CONDITIONAL_RSL.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table CONDITIONAL_RSL to bring in fields from the CONDITIONAL_RSL table 
        
      (SELECT 
        SIM.SECTIONID,
        SEG.FUNC_CLASS,
        'CI_FUNCTIONAL' ATTRIBUTE_,
      SIM.CI_FUNCTIONAL_{2} VALUE_,
      REP.YEARS YEAR_
      FROM SIMULATION_{0}_{1} SIM,
        SECTION_{0} SEC,
        SEGMENT_{0}_NS0 SEG,        
        REPORT_{0}_{1} REP        

      WHERE 
      SEG.SECTIONID = SIM.SECTIONID
      AND SEC.SECTIONID = SIM.SECTIONID
      AND REP.SECTIONID = SIM.SECTIONID
      AND REP.YEARS = {2}         
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate FCI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS  
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MIN(SKID_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates attribute decreases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT 
      END)
    ELSE --positive slope indicates attribute increases 0-50 in CONDITIONAL_RSL table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END SKID_RSL
    FROM
    (
      SELECT 
      CONDITIONAL_RSL.ATTRIBUTE,
      SL_IN.FUNC_CLASS,
      CONDITIONAL_RSL.BIN,
      CONDITIONAL_RSL.VALUE,
      SL_IN.SLOPE, 
      SL_IN.INTERCEPT
      FROM CONDITIONAL_RSL,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM CONDITIONAL_RSL   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
         
         UNION
         
          SELECT ATTRIBUTE, 
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS, 
           CRITERIA,
          '50' END_BIN,  
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM CONDITIONAL_RSL   
           WHERE BIN IN (20,50)
           GROUP BY ATTRIBUTE,
          CASE WHEN REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,1) || REGEXP_SUBSTR(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
          ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
          WHERE CONDITIONAL_RSL.ATTRIBUTE = SL_IN.ATTRIBUTE
          AND CONDITIONAL_RSL.CRITERIA = SL_IN.CRITERIA
          AND CONDITIONAL_RSL.BIN = SL_IN.END_BIN 
          ) SLOPE_INTERCEPT, -- join subquery SL_IN and table CONDITIONAL_RSL to bring in fields from the CONDITIONAL_RSL table 
        
      (SELECT 
        SIM.SECTIONID,
        SEG.FUNC_CLASS,
        'SPADJ_SKID_NUMBER' ATTRIBUTE_,
      SIM.SPADJ_SKID_NUMBER_{2} VALUE_,
      REP.YEARS YEAR_
      FROM SIMULATION_{0}_{1} SIM,
        SECTION_{0} SEC,
        SEGMENT_{0}_NS0 SEG,        
        REPORT_{0}_{1} REP        

      WHERE 
      SEG.SECTIONID = SIM.SECTIONID
      AND SEC.SECTIONID = SIM.SECTIONID
      AND REP.SECTIONID = SIM.SECTIONID
      AND REP.YEARS = {2}         
      ) Q1
   
      WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
      AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate SKID RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1)
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS) FQ -- pivot RSL for IRI, RUT, FCI, SCI, SPADJ_SKID_NUMBER (see below)

  PIVOT 
  (
    MAX(RSL)
    FOR ATTRIBUTE_ IN 
      ('AVG_IRI' AS IRI_RSL,
      'AVG_RUT' AS RUT_RSL,
      'CI_FUNCTIONAL' AS FCI_RSL,
      'CI_STRUCTURAL' AS SCI_RSL,
      'SPADJ_SKID_NUMBER' as SKID_RSL)
  )
  ) RSL_QRY  -- subquery returns RSL for IRI, RUT, FCI, SCI, SPADJ_SKID_NUMBER for all sections and years in the optimization

WHERE VAL_RSL.SECTIONID   = RSL_QRY.SECTIONID(+)
AND VAL_RSL.YEAR_       = RSL_QRY.YEAR_(+)
--ORDER BY 1,2");
        #endregion
        
        #region QueryTemplate to retrieve data for most recent year
        private static readonly string QueryTemplatemostrecentyr =
    new FormattedSql(@"
   SELECT 
   VAL_RSL.SECTIONID
  ,VAL_RSL.YEAR_ ""YEAR""
   ,'http://shagbegis1/egis/?initContent=124' || CHR(38) || 'initAttQuery=GLOBAL_ROUTE_ID%3D' || 
   VAL_RSL.GLOBAL_ROUTE_ID ||
   '%20and%20ID_MP%3E%3D' || 
   VAL_RSL.BEGIN_STATION || 
   '%20and%20ID_MP%3C%3D' || 
   VAL_RSL.END_STATION ||
   '%20and%20MP_DIRECTION%3DCAL_DIRECTION' || CHR(38) || 'initQueryLayer=100th%20milepoints' || CHR(38) || 'initQueryZoom=true' AS EGIS
  ,CAST(VAL_RSL.DISTRICT AS INT) ""DISTRICT""
  ,VAL_RSL.FACILITY
  ,VAL_RSL.SECTION
  ,VAL_RSL.BEGIN_STATION
  ,VAL_RSL.END_STATION
  ,VAL_RSL.SHOP
  ,VAL_RSL.DIR_MILES
  ,VAL_RSL.BEGIN_LIMIT
  ,VAL_RSL.END_LIMIT
  ,VAL_RSL.DIRECTION
  ,CAST(VAL_RSL.FUNC_CLASS AS INT)
  ,VAL_RSL.DIVIDED
  ,VAL_RSL.AREA
  ,VAL_RSL.AADT
  ,VAL_RSL.VMT
  ,CAST(VAL_RSL.GOVT_CONTROL AS INT)
  ,CASE WHEN VAL_RSL.NHS_CODE > 0 THEN 'Yes' ELSE 'No' END NHS
  ,VAL_RSL.PAVEMENT_TYPE
  ,CAST(VAL_RSL.GLOBAL_ROUTE_ID AS INT)
 -- ,VAL_RSL.LAST_TREATMENT
 -- ,CAST(VAL_RSL.LAST_YEAR AS INT)
  ,VAL_RSL.LAST_REHAB_TREATMENT AS ""LAST REHAB TREATMENT"" --  ,VAL_RSL.LAST_REHAB_TREATMENT
  ,CAST(VAL_RSL.LAST_REHAB_YEAR AS INT) AS ""LAST REHAB YEAR"" --  ,VAL_RSL.LAST_REHAB_YEAR
  ,VAL_RSL.LAST_MAINT_TREATMENT AS ""LAST MAINT TREATMENT"" --  ,VAL_RSL.LAST_MAINT_TREATMENT
  ,CAST(VAL_RSL.LAST_MAINT_YEAR AS INT) AS ""LAST MAINT YEAR"" --  ,VAL_RSL.LAST_MAINT_YEAR
  ,CASE WHEN VAL_RSL.PUBLIC_MAP_15 IS NOT NULL THEN 'Yes' ELSE NULL END ""GOVERNOR'S LIST""
  ,VAL_RSL.ROAD_CLASS
 --  ,CAST(VAL_RSL.FC_CATEGORY AS INT)
 --  ,VAL_RSL.TOTAL_LANES
  ,VAL_RSL.AVG_IRI
  ,VAL_RSL.CI_FUNCTIONAL
  ,VAL_RSL.CI_STRUCTURAL
  ,VAL_RSL.AVG_RUT
  ,VAL_RSL.SPADJ_SKID_NUMBER
  ,VAL_RSL.FAULTING  --placeholder for Faulting
  ,VAL_RSL.JC_CRACKED_SLABS AS ""JC CRACKED SLABS""  --placeholder for JC Cracked Slabs
  ,VAL_RSL.CRC_CRACKING_PERCENT AS ""CRC CRACKING PERCENT""  --placeholder for CRC Cracking Percent
  ,RSL_QRY.IRI_RSL
  ,RSL_QRY.FCI_RSL
  ,RSL_QRY.SCI_RSL
  ,RSL_QRY.RUT_RSL
  ,RSL_QRY.SKID_RSL
  ,CASE 
    WHEN RSL_QRY.IRI_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.IRI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.IRI_RSL
    WHEN RSL_QRY.FCI_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.FCI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.FCI_RSL
    WHEN RSL_QRY.SCI_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.RUT_RSL AND RSL_QRY.SCI_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.SCI_RSL
    WHEN RSL_QRY.RUT_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.RUT_RSL<=RSL_QRY.SKID_RSL THEN RSL_QRY.RUT_RSL
    WHEN RSL_QRY.SKID_RSL<=RSL_QRY.IRI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.FCI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.SCI_RSL AND RSL_QRY.SKID_RSL<=RSL_QRY.RUT_RSL THEN RSL_QRY.SKID_RSL 
  END RSL_OVERALL
FROM 
  (SELECT SEC.SECTIONID,
  INV.FIRSTYEAR-1 YEAR_,
  SEG.DISTRICT DISTRICT,
  SEC.FACILITY,
  CASE
    WHEN SEC.BEGIN_STATION > 0
    AND SEC.BEGIN_STATION  < 1
    THEN '0'|| SEC.BEGIN_STATION
    ELSE TRIM(TO_CHAR(SEC.BEGIN_STATION))
  END
  || '-'
  ||
  CASE
    WHEN SEC.END_STATION > 0
    AND SEC.END_STATION  < 1
    THEN '0'|| SEC.END_STATION
    ELSE TRIM(TO_CHAR(SEC.END_STATION))
  END
  || '('
  || SEC.DIRECTION
  || ')' SECTION,
  SEC.BEGIN_STATION,
  SEC.END_STATION,
  SEG.SHOP SHOP,
  (SEC.END_STATION - SEC.BEGIN_STATION) DIR_MILES,
  SEG.BEGIN_LIMIT,
  SEG.END_LIMIT,
  CASE
    WHEN SEG.DIVIDED = 'DIVIDED'
    THEN SEC.DIRECTION
      || 'B ONLY'
    ELSE 'ALL DIR'
  END DIRECTION,
  SEG.FUNC_CLASS,
  SEG.DIVIDED DIVIDED,
  SEC.AREA,    
  ROUND(SEG.AADT_VMT*(SEC.END_STATION - SEC.BEGIN_STATION), 0) VMT,
  SEG.GOVT_CONTROL,
  SEG.NHS_CODE,
  SEG.PAVEMENT_TYPE,
  SEG.GLOBAL_ROUTE_ID,
  SEG.LAST_TREATMENT,
  SEG.LAST_YEAR,
  SEG.LAST_REHAB_TREATMENT,
  SEG.LAST_REHAB_YEAR,
  SEG.LAST_MAINT_TREATMENT,
  SEG.LAST_MAINT_YEAR,
  SEG.PUBLIC_MAP_15,
  SEG.ROAD_CLASS,
 -- SEG.FC_CATEGORY,
 -- SEG.TOTAL_LANES,
  SEG.AADT_VMT AADT,
  SEG.AVG_IRI,
  SEG.CI_FUNCTIONAL,
  SEG.CI_STRUCTURAL,
  SEG.AVG_RUT,
  SEG.SPADJ_SKID_NUMBER,
  SEG.FAULTING_{2} FAULTING,
  SEG.JC_CRACKED_SLABS_{2} JC_CRACKED_SLABS,
  SEG.CRC_CRACKING_PERCENT_{2} CRC CRACKING PERCENT
  FROM SEGMENT_{0}_NS0 SEG,
  SECTION_{0} SEC,
  SIMULATION_{0}_{1} SIM,
  INVESTMENTS INV
    
  WHERE 
  SEG.SECTIONID = SEC.SECTIONID
  AND SEG.SECTIONID = SIM.SECTIONID
  AND INV.SIMULATIONID = {1}
  ORDER BY 1,2) VAL_RSL,  -- subquery VAL_RSL returns select attribute-value pairs for each section and year
  
(SELECT *
FROM
  (SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(IRI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END IRI_RSL
    FROM
    (
    SELECT 
    conditional_rsl.ATTRIBUTE,
    SL_IN.FUNC_CLASS,
    conditional_rsl.BIN,
    conditional_rsl.VALUE,
    SL_IN.SLOPE, 
    SL_IN.INTERCEPT
    FROM conditional_rsl,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM conditional_rsl   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
           
           UNION
           
          SELECT ATTRIBUTE, 
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
           CRITERIA,
          '50' END_BIN,  
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM conditional_rsl   
           WHERE BIN IN (20,50)
           GROUP BY ATTRIBUTE,
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
          ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
          
          WHERE conditional_rsl.ATTRIBUTE = SL_IN.ATTRIBUTE
          AND conditional_rsl.CRITERIA = SL_IN.CRITERIA
          AND conditional_rsl.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table conditional_rsl to bring in fields from the conditional_rsl table 
        
      (
        SELECT SECTIONID,
        FUNC_CLASS, 
        COL ATTRIBUTE_, 
        VALUE_,  
        YEAR_
        
        FROM 
        (
          SELECT 
              SEC.SECTIONID,
              SEG.FUNC_CLASS,
            UPV_AVG_IRI.AVG_IRI,
            UPV_AVG_IRI.YEAR_
            FROM SIMULATION_{0}_{1} SIM,
              SECTION_{0} SEC,
              SEGMENT_{0}_NS0 SEG,        
          
	(SELECT SECTIONID,INV.FIRSTYEAR-1 YEAR_,AVG_IRI FROM SEGMENT_{0}_NS0 SEG,
	  INVESTMENTS INV
	WHERE INV.SIMULATIONID = {1}
	) UPV_AVG_IRI            
              
            WHERE 
            SEG.SECTIONID = SIM.SECTIONID
            AND SEC.SECTIONID = UPV_AVG_IRI.SECTIONID
            AND SEG.SECTIONID = UPV_AVG_IRI.SECTIONID
            
          ) UNPIV_ATTRIBUTE
          
            UNPIVOT
          (
            VALUE_ FOR COL IN 
            (AVG_IRI)
          )  
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate IRI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
    
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(RUT_RSL) RSL
  FROM
    (
      SELECT Q1.SECTIONID, 
      Q1.ATTRIBUTE_,
      Q1.VALUE_,
      SLOPE_INTERCEPT.VALUE,
      Q1.YEAR_,
      SLOPE_INTERCEPT.FUNC_CLASS,
      SLOPE_INTERCEPT.BIN,
      CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in conditional_rsl table 
        (CASE 
        WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
        WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
        WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
        THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
        END)
      ELSE --positive slope indicates that the attribute increases 0-50 in conditional_rsl table 
        (CASE 
        WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
        WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
        WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
        THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
        END)
      END RUT_RSL 
      FROM
      (
        SELECT 
        conditional_rsl.ATTRIBUTE,
        SL_IN.FUNC_CLASS,
        conditional_rsl.BIN,
        conditional_rsl.VALUE,
        SL_IN.SLOPE, 
        SL_IN.INTERCEPT
        FROM conditional_rsl,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM conditional_rsl   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
         
          UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM conditional_rsl   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
      ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE conditional_rsl.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND conditional_rsl.CRITERIA = SL_IN.CRITERIA
        AND conditional_rsl.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table conditional_rsl to bring in fields from the conditional_rsl table 
        
      (
        SELECT SECTIONID,
        FUNC_CLASS, 
        COL ATTRIBUTE_, 
        VALUE_,  
        YEAR_
        
        FROM 
        (
          SELECT 
              SEC.SECTIONID,
              SEG.FUNC_CLASS,
            UPV_AVG_RUT.AVG_RUT AVG_RUT,
            UPV_AVG_RUT.YEAR_
            FROM SIMULATION_{0}_{1} SIM,
              SECTION_{0} SEC,
              SEGMENT_{0}_NS0 SEG,        
          
	(SELECT SECTIONID,INV.FIRSTYEAR-1 YEAR_,AVG_RUT FROM SEGMENT_{0}_NS0 SEG,
	  INVESTMENTS INV
	WHERE INV.SIMULATIONID = {1}
	) UPV_AVG_RUT    
              
            WHERE 
            SEG.SECTIONID = SIM.SECTIONID
            AND SEC.SECTIONID = UPV_AVG_RUT.SECTIONID
            AND SEG.SECTIONID = UPV_AVG_RUT.SECTIONID
            
          ) UNPIV_ATTRIBUTE
          
            UNPIVOT
          (
            VALUE_ FOR COL IN 
            (AVG_RUT)
          )  
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate RUT RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(SCI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END SCI_RSL
    FROM
    (
      SELECT 
      conditional_rsl.ATTRIBUTE,
      SL_IN.FUNC_CLASS,
      conditional_rsl.BIN,
      conditional_rsl.VALUE,
      SL_IN.SLOPE, 
      SL_IN.INTERCEPT
      FROM conditional_rsl,
      (
        SELECT ATTRIBUTE, 
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
        CRITERIA,
        '20' END_BIN,
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM conditional_rsl   
         WHERE BIN IN (0,20)
         GROUP BY ATTRIBUTE,
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
         
        UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM conditional_rsl   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
        ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE conditional_rsl.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND conditional_rsl.CRITERIA = SL_IN.CRITERIA
        AND conditional_rsl.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table conditional_rsl to bring in fields from the conditional_rsl table 
        
      (
        SELECT SECTIONID,
        FUNC_CLASS, 
        COL ATTRIBUTE_, 
        VALUE_,  
        YEAR_
        
        FROM 
        (
          SELECT 
              SEC.SECTIONID,
              SEG.FUNC_CLASS,
            UPV_CI_STRUCTURAL.CI_STRUCTURAL,
            UPV_CI_STRUCTURAL.YEAR_
            FROM SIMULATION_{0}_{1} SIM,
              SECTION_{0} SEC,
              SEGMENT_{0}_NS0 SEG,        
          
	(SELECT SECTIONID,INV.FIRSTYEAR-1 YEAR_,CI_STRUCTURAL FROM SEGMENT_{0}_NS0 SEG,
	  INVESTMENTS INV
	WHERE INV.SIMULATIONID = {1}
	) UPV_CI_STRUCTURAL 
                          
            WHERE 
            SEG.SECTIONID = SIM.SECTIONID
            AND SEC.SECTIONID = UPV_CI_STRUCTURAL.SECTIONID
            AND SEG.SECTIONID = UPV_CI_STRUCTURAL.SECTIONID
            
          ) UNPIV_ATTRIBUTE
          
            UNPIVOT
          (
            VALUE_ FOR COL IN 
            (CI_STRUCTURAL)
          )  
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate SCI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MAX(FCI_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates that the attribute decreases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates that the attribute increases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END FCI_RSL
    FROM
    (
    SELECT 
    conditional_rsl.ATTRIBUTE,
    SL_IN.FUNC_CLASS,
    conditional_rsl.BIN,
    conditional_rsl.VALUE,
    SL_IN.SLOPE, 
    SL_IN.INTERCEPT
    FROM conditional_rsl,
      (
      SELECT ATTRIBUTE, 
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
        CRITERIA,
        '20' END_BIN,
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM conditional_rsl   
         WHERE BIN IN (0,20)
         GROUP BY ATTRIBUTE,
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
         
        UNION
         
        SELECT ATTRIBUTE, 
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
         CRITERIA,
        '50' END_BIN,  
        REGR_SLOPE(BIN,VALUE) SLOPE,
        REGR_INTERCEPT(BIN,VALUE) INTERCEPT
         FROM conditional_rsl   
         WHERE BIN IN (20,50)
         GROUP BY ATTRIBUTE,
        CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
        ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
        CRITERIA
        ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
        WHERE conditional_rsl.ATTRIBUTE = SL_IN.ATTRIBUTE
        AND conditional_rsl.CRITERIA = SL_IN.CRITERIA
        AND conditional_rsl.BIN = SL_IN.END_BIN 
        ) SLOPE_INTERCEPT, -- join subquery SL_IN and table conditional_rsl to bring in fields from the conditional_rsl table 
        
      (
        SELECT SECTIONID,
        FUNC_CLASS, 
        COL ATTRIBUTE_, 
        VALUE_,  
        YEAR_
        
        FROM 
        (
          SELECT 
              SEC.SECTIONID,
              SEG.FUNC_CLASS,
            UPV_CI_FUNCTIONAL.CI_FUNCTIONAL,
            UPV_CI_FUNCTIONAL.YEAR_
            FROM SIMULATION_{0}_{1} SIM,
              SECTION_{0} SEC,
              SEGMENT_{0}_NS0 SEG,        
          
	(SELECT SECTIONID,INV.FIRSTYEAR-1 YEAR_,CI_FUNCTIONAL FROM SEGMENT_{0}_NS0 SEG,
	  INVESTMENTS INV
	WHERE INV.SIMULATIONID = {1}
	) UPV_CI_FUNCTIONAL         
              
            WHERE 
            SEG.SECTIONID = SIM.SECTIONID
            AND SEC.SECTIONID = UPV_CI_FUNCTIONAL.SECTIONID
            AND SEG.SECTIONID = UPV_CI_FUNCTIONAL.SECTIONID
            
          ) UNPIV_ATTRIBUTE
          
            UNPIVOT
          (
            VALUE_ FOR COL IN 
            (CI_FUNCTIONAL)
          )  
      ) Q1
   
    WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
    AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate FCI RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1) 
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS  
  
  UNION
  
  SELECT SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS,
  MIN(SKID_RSL) RSL
  FROM
    (
    SELECT Q1.SECTIONID, 
    Q1.ATTRIBUTE_,
    Q1.VALUE_,
    SLOPE_INTERCEPT.VALUE,
    Q1.YEAR_,
    SLOPE_INTERCEPT.FUNC_CLASS,
    SLOPE_INTERCEPT.BIN,
    CASE WHEN SLOPE_INTERCEPT.SLOPE < 0 THEN --negative slope indicates attribute decreases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ < SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ >= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50') 
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    ELSE --positive slope indicates attribute increases 0-50 in conditional_rsl table 
      (CASE 
      WHEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT < 0 THEN 0
      WHEN Q1.VALUE_ > SLOPE_INTERCEPT.VALUE AND SLOPE_INTERCEPT.BIN = '50' THEN 50
      WHEN Q1.VALUE_ <= SLOPE_INTERCEPT.VALUE AND (SLOPE_INTERCEPT.BIN = '20' OR SLOPE_INTERCEPT.BIN = '50')
      THEN SLOPE_INTERCEPT.SLOPE*Q1.VALUE_+SLOPE_INTERCEPT.INTERCEPT  
      END)
    END SKID_RSL
    FROM
    (
      SELECT 
      conditional_rsl.ATTRIBUTE,
      SL_IN.FUNC_CLASS,
      conditional_rsl.BIN,
      conditional_rsl.VALUE,
      SL_IN.SLOPE, 
      SL_IN.INTERCEPT
      FROM conditional_rsl,
      (
        SELECT ATTRIBUTE, 
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
          CRITERIA,
          '20' END_BIN,
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM conditional_rsl   
           WHERE BIN IN (0,20)
           GROUP BY ATTRIBUTE,
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
         
         UNION
         
          SELECT ATTRIBUTE, 
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END FUNC_CLASS  , 
           CRITERIA,
          '50' END_BIN,  
          REGR_SLOPE(BIN,VALUE) SLOPE,
          REGR_INTERCEPT(BIN,VALUE) INTERCEPT
           FROM conditional_rsl   
           WHERE BIN IN (20,50)
           GROUP BY ATTRIBUTE,
          CASE WHEN regexp_substr(CRITERIA,'[[:digit:]]',1,2) IS NULL THEN TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1))
          ELSE TO_NUMBER(regexp_substr(CRITERIA,'[[:digit:]]',1,1) || regexp_substr(CRITERIA,'[[:digit:]]',1,2)) END,
          CRITERIA
          ) SL_IN --subquery SL_IN returns slope and intercept for bin groups 0-20 and 20-50
        
          WHERE conditional_rsl.ATTRIBUTE = SL_IN.ATTRIBUTE
          AND conditional_rsl.CRITERIA = SL_IN.CRITERIA
          AND conditional_rsl.BIN = SL_IN.END_BIN 
          ) SLOPE_INTERCEPT, -- join subquery SL_IN and table conditional_rsl to bring in fields from the conditional_rsl table 
        
      (
        SELECT SECTIONID,
        FUNC_CLASS, 
        COL ATTRIBUTE_, 
        VALUE_,  
        YEAR_
        
        FROM 
        (
          SELECT 
              SEC.SECTIONID,
              SEG.FUNC_CLASS,
            CASE WHEN SEG.AGE IS NULL THEN SEG.SPADJ_SKID_NUMBER ELSE UPV_SPADJ_SKID_NUMBER.SPADJ_SKID_NUMBER END ""SPADJ_SKID_NUMBER"",
            UPV_SPADJ_SKID_NUMBER.YEAR_
            FROM SIMULATION_{0}_{1} SIM,
              SECTION_{0} SEC,
              SEGMENT_{0}_NS0 SEG,        
          
	(SELECT SECTIONID,INV.FIRSTYEAR-1 YEAR_,SPADJ_SKID_NUMBER FROM SEGMENT_{0}_NS0 SEG,
	  INVESTMENTS INV
	WHERE INV.SIMULATIONID = {1}
	) UPV_SPADJ_SKID_NUMBER            
              
            WHERE 
            SEG.SECTIONID = SIM.SECTIONID
            AND SEC.SECTIONID = UPV_SPADJ_SKID_NUMBER.SECTIONID
            AND SEG.SECTIONID = UPV_SPADJ_SKID_NUMBER.SECTIONID
            
          ) UNPIV_ATTRIBUTE
          
            UNPIVOT
          (
            VALUE_ FOR COL IN 
            (SPADJ_SKID_NUMBER)
          )  
      ) Q1
   
      WHERE Q1.attribute_ = SLOPE_INTERCEPT.ATTRIBUTE
      AND Q1.FUNC_CLASS = SLOPE_INTERCEPT.FUNC_CLASS
    ) Q2  -- calculate SKID RSL by joining linear regression query (SLOPE_INTERCEPT) and attribute/Highway Functional Class query (Q1)
  
  GROUP BY SECTIONID, 
  ATTRIBUTE_,
  YEAR_,
  FUNC_CLASS) FQ -- pivot RSL for IRI, RUT, FCI, SCI, SPADJ_SKID_NUMBER (see below)

  PIVOT 
  (
    MAX(RSL)
    FOR ATTRIBUTE_ IN 
      ('AVG_IRI' AS IRI_RSL,
      'AVG_RUT' AS RUT_RSL,
      'CI_FUNCTIONAL' AS FCI_RSL,
      'CI_STRUCTURAL' AS SCI_RSL,
      'SPADJ_SKID_NUMBER' AS SKID_RSL)
  )
  ) RSL_QRY -- subquery returns RSL for IRI, RUT, FCI, SCI, SPADJ_SKID_NUMBER for all sections and years in the optimization


WHERE 
VAL_RSL.SECTIONID   = RSL_QRY.SECTIONID(+)
AND VAL_RSL.YEAR_       = RSL_QRY.YEAR_(+)");
        #endregion

        #region Querytemplate for treatment cell values (Cost, Life Extension, LMY, $/LMY, and Limiting Measure)
    private static readonly string TreatmentsPerSectionQuery =
    new FormattedSql(@"
    -- updated TreatmentsPerSection query added on 11-12-2015 by Aditya
    -- this query now includes cost, modeled life extension, benefit (LMY), and $/LMY for each treatment
    SELECT DISTINCT BC.SECTIONID,
    BC.YEARS,
    BC.TREATMENT,
    BC.TREATMENT || ' Cost' TCOST,
    BC.TREATMENT || ' Life Extension' TLEXT,
    BC.TREATMENT || ' LMY' TLMY,
    BC.TREATMENT || ' $/LMY' TCOSTPERLMY,
    BC.TREATMENT || ' Limiting Measure' TLIMITINGMEASURE,
    ROUND(BC.COST_*REP.AREA*POWER(1+(INV.INFLATIONRATE/100),{2}-INV.FIRSTYEAR),0) COST,
    BC.REMAINING_LIFE LIFE_EXTENSION,
    BC.REMAINING_LIFE*SEC.AREA LMY,
    CASE WHEN BC.REMAINING_LIFE*SEC.AREA = 0 THEN 0 
    ELSE ROUND((BC.COST_*REP.AREA*POWER(1+(INV.INFLATIONRATE/100),BC.YEARS-INV.FIRSTYEAR))/(BC.REMAINING_LIFE*SEC.AREA),0) END COSTPERLMY,
    CASE WHEN round(BC.REMAINING_LIFE,1) = 
    (CASE WHEN regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1)= 0 THEN NULL
    WHEN (regexp_substr(BC.RLHASH,'[[:digit:]]+',regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),1) IS NULL 
    AND regexp_substr(BC.RLHASH,'[[:digit:]]+',regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),2) IS NULL) THEN 0 ELSE
    TO_NUMBER(REGEXP_SUBSTR(BC.RLHASH,'[[:digit:]]+',REGEXP_INSTR (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),1)||'.'|| REGEXP_SUBSTR(BC.RLHASH,'[[:digit:]]+',REGEXP_INSTR (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),2)) END) THEN ATTRIB_LIST.ATTRIBUTE_
    END LIMITING_MEASURE
    FROM BENEFITCOST_{0}_{1} BC,
    REPORT_{0}_{1} REP,
    INVESTMENTS INV,
    SECTION_{0} SEC,
    (SELECT PERF.SIMULATIONID, PERF.ATTRIBUTE_ FROM PERFORMANCE PERF,
    (SELECT ATTRIBUTE FROM CONDITIONAL_RSL) CRSL
    WHERE PERF.SIMULATIONID = {1}
    AND PERF.ATTRIBUTE_ = CRSL.ATTRIBUTE
    GROUP BY SIMULATIONID, ATTRIBUTE_) ATTRIB_LIST
    WHERE REP.SECTIONID = BC.SECTIONID
    AND SEC.SECTIONID = BC.SECTIONID
    AND BC.YEARS = {2}
    AND INV.SIMULATIONID = {1}
    AND BC.TREATMENT <> 'No Treatment'
    AND round(BC.REMAINING_LIFE,1) = 
    (CASE WHEN regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1)= 0 THEN NULL
    WHEN (regexp_substr(BC.RLHASH,'[[:digit:]]+',regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),1) IS NULL 
    AND regexp_substr(BC.RLHASH,'[[:digit:]]+',regexp_instr (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),2) IS NULL) THEN 0 ELSE
    TO_NUMBER(REGEXP_SUBSTR(BC.RLHASH,'[[:digit:]]+',REGEXP_INSTR (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),1)||'.'|| REGEXP_SUBSTR(BC.RLHASH,'[[:digit:]]+',REGEXP_INSTR (BC.RLHASH, ATTRIB_LIST.ATTRIBUTE_,1),2)) END)
");
        #endregion

        #region Querytemplate for treatment headers
        private static readonly string AllTreatmentsQuery =
        new FormattedSql(@"
        SELECT treatment
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        #region Querytemplate for treatment cost headers
        private static readonly string AllTreatmentCostQuery =
        new FormattedSql(@"
        SELECT 
        treatment || ' Cost' TCOST
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        #region Querytemplate for treatment life extension headers
        private static readonly string AllTreatmentLifeExtensionQuery =
        new FormattedSql(@"
        SELECT 
        treatment || ' Life Extension' TLEXT
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        #region Querytemplate for treatment benefit (LMY) headers
        private static readonly string AllTreatmentLMYQuery =
        new FormattedSql(@"
        SELECT 
        treatment || ' LMY' TLMY
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        #region Querytemplate for treatment $/LMY headers
        private static readonly string AllTreatmentCostperLMYQuery =
        new FormattedSql(@"
        SELECT 
        treatment || ' $/LMY' TCOSTPERLMY
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        #region Querytemplate for treatment limiting measure headers
        private static readonly string AllTreatmentLimitingMeasureQuery =
        new FormattedSql(@"
        SELECT 
        treatment || ' Limiting Measure' TLMTMEASURE
        FROM treatments
        WHERE simulationid = {0}
        and treatment <> 'No Treatment'
        ORDER BY description
        ");
        #endregion

        private const double MaxColumnWidthFactor = 2;

        private const double RslColumnWidth = 4.7;

        private const double MinRslValue = 0;

        private const double MaxRslValue = 50;

        private static readonly Color HyperlinkBlue = Color.FromArgb(0, 0, 255);

        private static readonly Color MdshaGray = Color.FromArgb(217, 217, 217);

        private static readonly Color MdshaLightBlue = Color.FromArgb(197, 217, 241);

        private static readonly Color MdshaLightGreen = Color.FromArgb(235, 241, 222);

        private static readonly Color RslMaroon = Color.FromArgb(192, 0, 0);

        private static readonly Color RslBlue = Color.FromArgb(0, 176, 240);

        private static readonly Color RslGreen = Color.FromArgb(146, 208, 80);

        private static readonly Color RslYellow = Color.FromArgb(255, 255, 0);

        private static readonly Color RslOrange = Color.FromArgb(255, 192, 0);

        private static readonly Color RslRed = Color.FromArgb(255, 0, 0);

        private static readonly Color TreatmentPeach = Color.FromArgb(252, 213, 180);

        private static readonly Color TreatmentGreen = Color.FromArgb(146, 208, 80);

        private readonly string SectionQuery;

        private readonly string TreatmentQuery;

        private readonly string[] AllTreatments;

        private readonly string[] AllTreatmentsCost;

        private readonly string[] AllTreatmentsLifeExtension;

        private readonly string[] AllTreatmentsLMY;

        private readonly string[] AllTreatmentsCostPerLMY;

        private readonly string[] AllTreatmentsLimitingMeasure;

        private DataTable SectionData;

        private DataTable TreatmentData;

        /// <summary>
        ///     Create a new "All Sections" report given the
        ///     appropriate network/simulation information.
        /// </summary>
        /// <param name="networkId"></param>
        /// <param name="simulationId"></param>
        /// <param name="simulation"></param> 
public Report(
    string networkId,
    string simulationId,
    string simulation)
    {
	    this.NetworkId = networkId;
        this.SimulationId = simulationId; 
	    this.Simulation = simulation;  

        // Formatted SectionQuery string for all simulation analysis years
        var subQueryCompound = string.Join(
            " UNION ",  
            Utilities.GetAnalysisYears(simulationId)
            .Select(year =>
                string.Format(
                    Report.QueryTemplate,
                    networkId,
                    simulationId,
                    year)));

        // Formatted SectionQuery string for the most recent year
        var subQueryCompound3 = 
            string.Format(
                Report.QueryTemplatemostrecentyr,
                networkId,
                simulationId);
        
        // Union and order by sectionid, year
        var subQueryCompound4 = subQueryCompound + " UNION " + subQueryCompound3 + " ORDER BY 1,2";

        #region Store treatment names, cost, life extension, LMY, $/LMY, and limiting measure
        try
        {
            this.AllTreatments =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentsQuery, 
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();

            this.AllTreatmentsCost =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentCostQuery,
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();

            this.AllTreatmentsLifeExtension =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentLifeExtensionQuery,
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();

            this.AllTreatmentsLMY =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentLMYQuery,
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();

            this.AllTreatmentsCostPerLMY =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentCostperLMYQuery,
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();

            this.AllTreatmentsLimitingMeasure =
                DBMgr.ExecuteQuery(
                    string.Format(
                        Report.AllTreatmentLimitingMeasureQuery,
                        this.SimulationId))
                .Tables[0]
                .AsEnumerable()
                .Select(r => r.Field<string>(0))
                .ToArray();
        }
        catch (DbException e)
        {
            throw new ReportGenerationException(e.Message, e);
        }
        #endregion

        // This is now a simulation report
	    this.OutputFileBaseName =
            string.Format("{0} - {1}", Title, simulation);

        this.SectionQuery = string.Format(
            subQueryCompound4, 
            this.NetworkId,
            this.SimulationId);

        // Formatted TreatmentQuery string with treatment costs for all simulation analysis years
        var subQueryCompound2 = String.Join(
        " UNION ",  
        Utilities.GetAnalysisYearsInclMostRecent(simulationId)
        .Select(year =>
        string.Format(
        Report.TreatmentsPerSectionQuery,
        networkId,
        simulationId,
        year)));

        this.TreatmentQuery = string.Format(
            subQueryCompound2,
            this.NetworkId,
            this.SimulationId);
        }

        /// <summary>
        ///     Returns the title of this specific report instance.
        /// </summary>
        /// <remarks>
        ///     This is virtual so that the base class can use it while the
        ///     subclasses define it.
        /// </remarks>
        public override string Title
        {
            get { return GenericTitle; }
        }

        /// <summary>
        ///     Gets the report's data (to fail fast if this report cannot be
        ///     used with the given net/sim). Prepares the working OOXML package
        ///     and output file for writing.
        /// </summary>
        protected override void Open()
        {
            this.SectionData =
                DBMgr.ExecuteQuery(this.SectionQuery).Tables[0];

            this.TreatmentData =
                DBMgr.ExecuteQuery(this.TreatmentQuery).Tables[0];

            if (this.SectionData.Rows.Count == 0 ||
                this.TreatmentData.Rows.Count == 0)
            {
                throw new ReportGenerationException(
                    "There is no data present for this report.");
            }

            this.OutputFileExtension = "xlsx";
            this.OutputPackage = new ExcelPackage(this.GetNewOutputFile());
        }

        /// <summary>
        ///     Prepares the report's data, loads it into the working package,
        ///     and formats the package content.
        /// </summary>
        protected override void Fill()
        {
            // First, append each section's treatment project costs
            this.SectionData.Columns.AddRange(
                this.AllTreatmentsCost
                .Select(t =>
                {
                    var c = new DataColumn(t, typeof(decimal));
                    return c;
                })
                .ToArray());
            // Second, append each section's treatment project life extension
            this.SectionData.Columns.AddRange(
                this.AllTreatmentsLifeExtension
                .Select(t =>
                {
                    var c = new DataColumn(t, typeof(decimal));
                    return c;
                })
                .ToArray());
            // Third, append each section's treatment project benefit (LMY)
            this.SectionData.Columns.AddRange(
                this.AllTreatmentsLMY
                .Select(t =>
                {
                    var c = new DataColumn(t, typeof(decimal));
                    return c;
                })
                .ToArray());
            // Fourth, append each section's treatment project $/LMY
            this.SectionData.Columns.AddRange(
                this.AllTreatmentsCostPerLMY
                .Select(t =>
                {
                    var c = new DataColumn(t, typeof(decimal));
                    return c;
                })
                .ToArray());
            // Finally, append each section's treatment project limiting measure
            this.SectionData.Columns.AddRange(
                this.AllTreatmentsLimitingMeasure
                .Select(t =>
                {
                    var c = new DataColumn(t, typeof(string));
                    return c;
                })
                .ToArray());

            var eachSectionWithTreatments =
                from section in this.SectionData.AsEnumerable()
                join treatment in this.TreatmentData.AsEnumerable() on 
                new { SectionID = section.Field<decimal>("SECTIONID"), YEAR = section.Field<decimal>("YEAR") }
               equals
                 new { SectionID = treatment.Field<decimal>("SECTIONID"), YEAR = treatment.Field<decimal>("YEARS") }
                 into treatments
                select new { section, treatments };

            // For each section, show the treatment cost, life extension, benefit (LMY), and $/LMY
            foreach (var st in eachSectionWithTreatments)
            {
                foreach (var t in st.treatments)
                {
                    st.section.SetField(
                        t.Field<string>("TCOST"),
                        t.Field<decimal>("COST"));

                    st.section.SetField(
                        t.Field<string>("TLEXT"),
                        t.Field<double>("LIFE_EXTENSION"));

                    st.section.SetField(
                        t.Field<string>("TLMY"),
                        t.Field<decimal>("LMY"));

                    st.section.SetField(
                        t.Field<string>("TCOSTPERLMY"),
                        t.Field<decimal>("COSTPERLMY"));

                    st.section.SetField(
                        t.Field<string>("TLIMITINGMEASURE"),
                        t.Field<string>("LIMITING_MEASURE"));
                }
            }

            // And now, load and format the report...
            var sheet =
                this.OutputPackage.Workbook.Worksheets.Add(Report.GenericTitle);

            // PERFORMANCE-CRITICAL: This nested loop pre-creates the sheet
            // cells that will be formatted and filled in. This results in a
            // measured order-of-magnitude speed improvement (and is
            // corroborated by an official FAQ answer from EPPlus's creator).
            var lastRow = 1 + this.SectionData.Rows.Count;
            var lastCol = this.SectionData.Columns.Count;
            for (var r = 1; r <= lastRow; ++r)
            {
                for (var c = 1; c <= lastCol; ++c)
                {
                    sheet.Cells[r, c].Value = null;
                }
            }

            // Apply basic/default formatting...
            var headers = sheet.Cells.Offset(0, 0, 1, this.SectionData.Columns.Count);
            headers.Style.Font.Bold = true;

            headers.Style.Fill.PatternType = ExcelFillStyle.Solid;
            headers.Style.Fill.BackgroundColor.SetColor(Report.MdshaGray);

            headers.Style.HorizontalAlignment = ExcelHorizontalAlignment.Center;
            headers.Style.VerticalAlignment = ExcelVerticalAlignment.Center;

            // Increase the header row height
            sheet.Row(1).Height *= 4;

              //Show only one decimal place for lane miles
            sheet.Cells
                .Offset(
                    0,
                    this.SectionData.Columns["LANE MILES"].Ordinal,
                    this.SectionData.Rows.Count + 1,
                    1)
                .Style.Numberformat.Format = "0.0";

            // Apply formatting to the eight (8) measure columns
            var measures = sheet.Cells.Offset(
                1,
                this.SectionData.Columns["AVG IRI"].Ordinal,
                this.SectionData.Rows.Count,
                8);            
            var measuresrut = sheet.Cells.Offset(
                1,
                this.SectionData.Columns["AVG RUT"].Ordinal,
                this.SectionData.Rows.Count,
                1);

            // Show four decimal places for AVG_RUT.  Two decimal places for all other measures
            measures.Style.Numberformat.Format = "0.00";
            measuresrut.Style.Numberformat.Format = "0.0000";
            measures.Style.Fill.PatternType = ExcelFillStyle.Solid;
            measures.Style.Fill.BackgroundColor.SetColor(
                Report.MdshaLightGreen);

            // Apply formatting to the RSL columns
            var rslAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns["IRI RSL"].Ordinal + 1,
                this.SectionData.Rows.Count + 1,
                this.SectionData.Columns["RSL OVERALL"].Ordinal + 1);

            var rslRange = sheet.Cells[rslAddressString];
            rslRange.Style.Numberformat.Format = "0";
            rslRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            rslRange.Style.Fill.BackgroundColor.SetColor(Report.RslMaroon);

            // Apply conditional formatting to the RSL columns
            var rslAddress = new ExcelAddress(rslAddressString);

            var cfRslBlue =
                sheet.ConditionalFormatting.AddGreaterThanOrEqual(rslAddress);
            cfRslBlue.Priority = 1;
            cfRslBlue.StopIfTrue = true;
            cfRslBlue.Formula = "40";
            cfRslBlue.Style.Fill.BackgroundColor.Color = Report.RslBlue;

            var cfRslGreen =
                sheet.ConditionalFormatting.AddGreaterThanOrEqual(rslAddress);
            cfRslGreen.Priority = 2;
            cfRslGreen.StopIfTrue = true;
            cfRslGreen.Formula = "30";
            cfRslGreen.Style.Fill.BackgroundColor.Color = Report.RslGreen;

            var cfRslYellow =
                sheet.ConditionalFormatting.AddGreaterThanOrEqual(rslAddress);
            cfRslYellow.Priority = 3;
            cfRslYellow.StopIfTrue = true;
            cfRslYellow.Formula = "20";
            cfRslYellow.Style.Fill.BackgroundColor.Color = Report.RslYellow;

            var cfRslOrange =
                sheet.ConditionalFormatting.AddGreaterThanOrEqual(rslAddress);
            cfRslOrange.Priority = 4;
            cfRslOrange.StopIfTrue = true;
            cfRslOrange.Formula = "10";
            cfRslOrange.Style.Fill.BackgroundColor.Color = Report.RslOrange;

            var cfRslRed =
                sheet.ConditionalFormatting.AddGreaterThan(rslAddress);
            cfRslRed.Priority = 5;
            cfRslRed.StopIfTrue = true;
            cfRslRed.Formula = "0";
            cfRslRed.Style.Fill.BackgroundColor.Color = Report.RslRed;

            // Apply formatting to the treatment cost columns
            var treatmentsAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length*5) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count - this.AllTreatments.Length*4);

            var treatmentsRange = sheet.Cells[treatmentsAddressString];
            treatmentsRange.Style.Numberformat.Format =
                @"_($* #,##0_);_($* (#,##0);_($* ""-""??_);_(@_)";
            treatmentsRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            treatmentsRange.Style.Fill.BackgroundColor.SetColor(
                Report.TreatmentPeach);

            // Apply formatting to the treatment columns (life extension only)
            var treatmentslifeextAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length * 4) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count - this.AllTreatments.Length * 3);

            var treatmentslifeextRange = sheet.Cells[treatmentslifeextAddressString];
            treatmentslifeextRange.Style.Numberformat.Format = "0";
            treatmentslifeextRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            treatmentslifeextRange.Style.Fill.BackgroundColor.SetColor(
                Report.TreatmentPeach);

            // Apply formatting to the treatment LMY columns
            var treatmentslmyAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length * 3) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count - this.AllTreatments.Length * 2);

            var treatmentslmyRange = sheet.Cells[treatmentslmyAddressString];
            treatmentslmyRange.Style.Numberformat.Format = "0";
            treatmentslmyRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            treatmentslmyRange.Style.Fill.BackgroundColor.SetColor(
                Report.TreatmentPeach);

            // Apply formatting to the treatment $/LMY columns 
            var treatmentscostperlmyAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length * 2) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count - this.AllTreatments.Length * 1);

            var treatmentscostperlmyRange = sheet.Cells[treatmentscostperlmyAddressString];
            treatmentscostperlmyRange.Style.Numberformat.Format =
                @"_($* #,##0_);_($* (#,##0);_($* ""-""??_);_(@_)";
            treatmentscostperlmyRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            treatmentscostperlmyRange.Style.Fill.BackgroundColor.SetColor(
                Report.TreatmentPeach);

            // Apply formatting to the treatment limiting measure columns
            var treatmentslimitingmeasureAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length * 1) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count - this.AllTreatments.Length * 0);

            var treatmentslimitingmeasureRange = sheet.Cells[treatmentslimitingmeasureAddressString];
            treatmentslimitingmeasureRange.Style.Fill.PatternType = ExcelFillStyle.Solid;
            treatmentslimitingmeasureRange.Style.Fill.BackgroundColor.SetColor(
                Report.TreatmentPeach);

            // Apply conditional formatting to all treatment columns (cost, life extension, LMY, $/LMY, and limiting measure)
            var alltreatmentsAddressString = ExcelCellBase.GetAddress(
                2,
                this.SectionData.Columns.Count - (this.AllTreatments.Length * 5) + 1,
                1 + this.SectionData.Rows.Count,
                this.SectionData.Columns.Count);
            var treatmentsAddress = new ExcelAddress(alltreatmentsAddressString);

            var cfTreatmentGreen =
                sheet.ConditionalFormatting.AddNotContainsBlanks(treatmentsAddress);
            cfTreatmentGreen.Style.Fill.BackgroundColor.Color =
                Report.TreatmentGreen;

            // Load data and set borders
            var range = sheet.Cells.LoadFromDataTable(this.SectionData, true);
            range.BorderAllFaster(ExcelBorderStyle.Thin);

            // Show friendly name hyperlinks in eGIS column and format 
            int EGIScolnum = this.SectionData.Columns["EGIS"].Ordinal + 1;
            for (var r = 2; r <= lastRow; ++r)
            {
                sheet.Cells[r, EGIScolnum].Hyperlink = new Uri(sheet.Cells[r, EGIScolnum].Value.ToString());
                sheet.Cells[r, EGIScolnum].Value = "eGIS";
                sheet.Cells[r, EGIScolnum].Style.Font.UnderLine = true;
                sheet.Cells[r, EGIScolnum].Style.Font.Color.SetColor(HyperlinkBlue);
                sheet.Cells[r, EGIScolnum].Style.HorizontalAlignment = ExcelHorizontalAlignment.Center;
            }

            // Apply formatting to the leading non-measure columns
            var leadingNonMeasures = sheet.Cells.Offset(
                1,
                0,
                this.SectionData.Rows.Count,
               1 + this.SectionData.Columns["ROAD CLASS"].Ordinal);
            leadingNonMeasures.Style.Fill.PatternType = ExcelFillStyle.Solid;
            leadingNonMeasures.Style.Fill.BackgroundColor.SetColor(
                Report.MdshaLightBlue);

            // Set autofilter
            range.AutoFilter = true;

            // Set column widths
            sheet.Cells.AutoFitColumns(
                0,
                sheet.DefaultColWidth * Report.MaxColumnWidthFactor);

            // Wrap the header text
            headers.Style.WrapText = true;

            // Set the RSL value columns' widths to something that compresses
            // the view of all values (similar to the original example provided
            // by MDSHA)
            sheet.Column(this.SectionData.Columns["IRI RSL"].Ordinal + 1).Width =
                Report.RslColumnWidth;
            sheet.Column(this.SectionData.Columns["FCI RSL"].Ordinal + 1).Width =
                Report.RslColumnWidth;
            sheet.Column(this.SectionData.Columns["SCI RSL"].Ordinal + 1).Width =
                Report.RslColumnWidth;
            sheet.Column(this.SectionData.Columns["RUT RSL"].Ordinal + 1).Width =
                Report.RslColumnWidth;
            sheet.Column(this.SectionData.Columns["SKID RSL"].Ordinal + 1).Width =
                Report.RslColumnWidth;
            sheet.Column(this.SectionData.Columns["RSL OVERALL"].Ordinal + 1).Width =
                Report.RslColumnWidth * 2;

            // Freeze the header row (remember: one-based, not zero-based!)
            sheet.View.FreezePanes(2, 1);
        }

        /// <summary>
        ///     Saves the working package to the prepared output. Closes the
        ///     output stream.
        /// </summary>
        protected override void Save()
        {
            if (this.OutputPackage == null) return;

            this.OutputPackage.Save();
            this.OutputPackage.Stream.Dispose();
        }

    }

}
